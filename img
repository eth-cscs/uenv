#!/usr/bin/env python3
import argparse
import copy
import os
import pathlib
import re
import sys

prefix = pathlib.Path(__file__).parent.resolve()
libpath = prefix / 'lib'
sys.path = [libpath.as_posix()] + sys.path

import flock
import jfrog
import oras
import datastore
import terminal
import textwrap

def make_argparser():
    parser = argparse.ArgumentParser(
            formatter_class=argparse.RawDescriptionHelpFormatter,
            description=textwrap.dedent(
                """\
Interact with uenv.

uenv provides ...
                """
                ))
    parser.add_argument("--no-color",
            action="store_true",
            help="disable color output")
    parser.add_argument("-v", "--verbose",
            action="store_true",
            help="enable verbose output")
    parser.add_argument("-r", "--repo",
            required=False, default=None, type=str,
            help="the local repository")

    subparsers = parser.add_subparsers(dest="command")

    find_parser = subparsers.add_parser("find",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""\
Find uenv in the CSCS registry. Uenv can be downloaded from the registry using
the pull command, and list the downloaded uenv with the list command. For more
information:
  img pull --help
  img list --help

Example - find all uenv available (deployed) on this cluster:
  img find

Example - find all uenv with the name prgenv-gnu on this cluster:
  img find prgenv-gnu

Example - find all uenv with name prgenv-gnu and version 24.2 on this cluster:
  img find prgenv-gnu/24.2

Example - find the uenv with name prgenv-gnu, version 24.2 and tag "latest" on this cluster:
  img find prgenv-gnu/24.2:latest

Example - find all uenv with the name prgenv-gnu for uarch target zen3 on this cluster:
  img find prgenv-gnu --uarch=a100

Example - find all uenv that have a concrete sha245 checksum on this cluster:
  img find 3313739553fe6553f789a35325eb6954a37a7b85cdeab943d0878a05edaac998
  img find 3313739553fe6553     # the first 16 characters can be used

Example - find all uenv that have been generated as build artifacts on this cluster:
  img find --build
""")
    find_parser.add_argument("-s", "--system", required=False, type=str)
    find_parser.add_argument("-a", "--uarch", required=False, type=str)
    find_parser.add_argument("--build", action="store_true",
                             help="enable undeployed builds", required=False)
    find_parser.add_argument("uenv", nargs="?", default=None, type=str)

    pull_parser = subparsers.add_parser("pull", help="pull a uenv from the CSCS registry")
    pull_parser.add_argument("-s", "--system", required=False, type=str)
    pull_parser.add_argument("-a", "--uarch", required=False, type=str)
    pull_parser.add_argument("--build", action="store_true", required=False,
                             help="enable undeployed builds")
    pull_parser.add_argument("uenv", nargs="?", default=None, type=str)

    list_parser = subparsers.add_parser("list", help="list cached images")
    list_parser.add_argument("-s", "--system", required=False, type=str)
    list_parser.add_argument("-a", "--uarch", required=False, type=str)
    list_parser.add_argument("uenv", nargs="?", default=None, type=str)

    create_parser = subparsers.add_parser("create",
                    help="create a local file system repository")
    create_parser.add_argument("--exists-ok", action="store_true", required=False,
                    help="no error if the local registry exists")

    deploy_parser = subparsers.add_parser("deploy",
                    help="deploy a uenv to the 'deploy' namespace, visible to all users")
    deploy_parser.add_argument("-t", "--tag", required=False, default="latest", type=str)
    deploy_parser.add_argument("source", nargs="?", default=None, type=str)

    return parser

def get_options(args):
    options = {}
    if args.system is None:
        sys_name = os.getenv("CLUSTER_NAME")
        if sys_name is None:
            raise ValueError("No system name was provided, and the CLUSTER_NAME environment variable is not set.")
        options["system"] = sys_name
    else:
        options["system"] = args.system

    options["name"] = args.uenv
    options["uarch"] = args.uarch

    return options

def get_filter(args):
    # TODO: test "name" to see whether it is a sha/sha256
    options = get_options(args)
    img_filter = {"system": options["system"]}

    name = options["name"]
    if (name is not None) and datastore.DataStore.is_valid_sha(name):
        terminal.info(f"get_filter: search term {name} is being treated as a sha256")
        img_filter["sha"] = name
    elif name is not None:
        terminal.info(f"get_filter: search term {name} is being treated as a name")
        for key, value in parse_uenv_string(options["name"]).items():
            if value is not None:
                img_filter[key] = value
    else:
        terminal.info(f"get_filter: no search term provided")

    if options["uarch"] is not None:
        img_filter["uarch"] = options["uarch"]

    terminal.info(f"get_filter: filter {img_filter}")
    return img_filter


def relative_path_from_record(record):
    return f"{record.sha256}"


# pretty print a list of Record
def print_records(records):
    if len(records)>0:
        print(terminal.colorize(f"{'uenv/version:tag':40}{'uarch':6}{'date':10} {'sha256':16} {'size':<10}", "yellow"))
        for r in records:
            namestr = f"{r.name}/{r.version}"
            tagstr = f"{r.tag}"
            label = namestr + ":" + tagstr
            datestr = r.date.strftime("%Y-%m-%d")
            S = r.size
            if S<1024:
                size_str = f"{S:<} bytes"
            elif S<1024*1024:
                size_str = f"{(S/1024):<.0f} kB"
            elif S<1024*1024*1024:
                size_str = f"{(S/(1024*1024)):<.0f} MB"
            else:
                size_str = f"{(S/(1024*1024*1024)):<.1f} GB"
            print(f"{label:<40}{r.uarch:6}{datestr:10} {r.sha256[:16]:16} {size_str:<10}")

# return dictionary {"name", "version", "tag"} from a uenv description string
#       "prgenv_gnu"              -> ("prgenv_gnu", None, None)
#       "prgenv_gnu/23.11"        -> ("prgenv_gnu", "23.11", None)
#       "prgenv_gnu/23.11:latest" -> ("prgenv_gnu", "23.11", "latest")
def parse_uenv_string(desc: str) -> dict:
    name = version = tag = None

    if desc:
        splits = desc.split("/",1)
        name = splits[0]
        if len(splits)>1:
            splits = splits[1].split(":",1)
            version = splits[0]
            tag = splits[1] if len(splits)>1 else None

    return {"name": name, "version": version, "tag": tag}

# the path used to store a users cached images and meta data
def uenv_repo_path(path: str=None) -> str:
    if path is not None:
        return path

    # check whether the image path has been explicitly set:
    path = os.environ.get('UENV_REPO_PATH')
    if path is not None:
        return path

    # if not, try to use the path $SCRATCH/.uenv-images/, if SCRATCH exists
    path = os.environ.get('SCRATCH')
    if path is not None:
        return path + "/.uenv-images"

    terminal.error("No repository path available: set UENV_REPO_PATH or use the --repo flag")

if __name__ == "__main__":

    parser = make_argparser()
    args = parser.parse_args()

    if args.command is None:
        parser.print_help()
        sys.exit(0)

    terminal.use_colored_output(args.no_color)
    if args.verbose:
        terminal.set_debug_level(2)

    terminal.info(f"command mode: {args.command}")

    if args.command in ["find", "pull"]:
        img_filter = get_filter(args)
        terminal.info(f"using {'build' if args.build else 'deploy'} remote repo")

        try:
            deploy, build = jfrog.query()
        except RuntimeError as err:
            terminal.error(f"{str(err)}")

        terminal.info(f"downloaded jfrog meta data: build->{len(build.images)}, deploy->{len(deploy.images)}")

        remote_database = build if args.build else deploy

        records = remote_database.find_records(**img_filter)

        terminal.info(f"The following records matched the query: {records}")

        if args.command == "find":
            if len(records)>0:
                print_records(records)
            else:
                print("no images match the query")

        elif args.command == "pull":
            # verify that there is at least one image that matches the query
            if len(records)==0:
                terminal.error(f"no images match the query {args.uenv}")

            # check that there is only one uenv name
            if len(set([r.name for r in records]))>1:
                print_records(records)
                print()
                terminal.error(f"ambiguous uenv {args.uenv}")

            # check that there is only one uenv name
            if len(set([r.uarch for r in records]))>1:
                print_records(records)
                print()
                terminal.error(
                        "more than one uarch matches the the requested uenv. "
                        "Specify the desired uarch with the --uarch flag")

            t = records[0]
            source_address = jfrog.address(t, 'build' if args.build else 'deploy')

            terminal.info(f"pulling {t} from {source_address} {t.size/(1024*1024):.0f} MB")

            repo_path = uenv_repo_path(args.repo)
            terminal.info(f"repo path: {repo_path}")

            with flock.Lock(f"{repo_path}/index.json", flock.Lock.WRITE) as lk:
                cache = datastore.FileSystemCache(repo_path)

                image_path = cache.image_path(t)

                # if the record isn't already in the filesystem repo download it
                if not cache.get_record(t.sha256):
                    terminal.info(f"downloading {t.sha256}")
                    # download the image using oras
                    oras.run_command(["pull", "-o", image_path, source_address])
                    # add the record to the cache
                    terminal.info(f"updating file system cache")
                    cache.add_record(t)
                    # publish the updated index
                    terminal.info(f"publishing file system cache")
                    cache.publish()
                else:
                    terminal.info(f"image {t.sha256} is already in the cache")
                terminal.info(f"image downloaded at {image_path}/store.squashfs")

        sys.exit(0)

    elif args.command == "list":
        repo_path = uenv_repo_path(args.repo)
        terminal.info(f"repo path: {repo_path}")

        img_filter = get_filter(args)

        with flock.Lock(f"{repo_path}/index.json", flock.Lock.READ) as lk:
            fscache = datastore.FileSystemCache(repo_path)

            records = fscache.database.find_records(**img_filter)
            print_records(records)

        sys.exit(0)

    elif args.command == "create":
        repo_path = uenv_repo_path(args.repo)
        terminal.info(f"repo path: {repo_path}")

        try:
            datastore.FileSystemCache.create(repo_path, exists_ok=args.exists_ok)
        except Exception as err:
            terminal.error(f"unable to find or initialise the local registry: {str(err)}")

        sys.exit(0)

    elif args.command == "deploy":
        source = args.source
        terminal.info(f"trying to deploy {args.source} with tags {args.tag}")

        try:
            _, build_database = jfrog.query()
        except RuntimeError as err:
            terminal.error(f"{str(err)}")
        terminal.info(f"downloaded jfrog build meta data: {len(build_database.images)} images")

        # after this block, source_record is the record of the requested source
        if datastore.DataStore.is_valid_sha(source):
            # lookup using sha256
            source_record = build_database.get_record(source)
            terminal.info(f"searched for {source} in the build repo, found: {source_record}")
            if not source_record:
                terminal.error(f"no record in the build repository matches the hash {source}")
            source_record = source_record[0]
        else:
            img_filter = {}
            for key, value in parse_uenv_string(source).items():
                if value is not None:
                    img_filter[key] = value
                else:
                    terminal.error(f"source {source} must have full name/version:tag format")

            # expect that src has [name, version, tag] keys
            records = build_database.find_records(**img_filter)

            terminal.info(f"searched for {source} in the build repo, found: {records}")

            if not (len(records)==1):
                terminal.error(f"source {source} is not an image in the build repository")
            source_record = records[0]

        terminal.info(f"the source is {source_record}")

        target_record = copy.deepcopy(source_record)

        # create comma separated list of tags to be attached to the deployed image
        tags = [ tag.strip() for tag in args.tag.split(',') ]
        target_record.tag = ','.join(tags)

        terminal.info(f"source: {source_record}")
        source_address = jfrog.address(source_record, 'build')
        target_address = jfrog.address(target_record, 'deploy')
        terminal.info(f"source address: {source_address}")
        terminal.info(f"target address: {target_address}")

        #oras.run_command(["cp", "--concurrency", "10", "--recursive", source_address, target_address])

        terminal.info(f"successfully deployed {target_address}")

        sys.exit(0)


