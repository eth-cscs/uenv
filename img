#!/usr/bin/env python3
import argparse
import copy
import os
import pathlib
import re
import sys

prefix = pathlib.Path(__file__).parent.resolve()
libpath = prefix / 'lib'
sys.path = [libpath.as_posix()] + sys.path

import flock
import jfrog
import oras
import datastore
import terminal

def make_argparser():
    parser = argparse.ArgumentParser(description=("Interact with the uenv artifactory"))
    parser.add_argument("--no-color",
            action="store_true",
            help="disable color output")
    parser.add_argument("-r", "--repo",
            required=False, default=None, type=str,
            help="the local repository")

    subparsers = parser.add_subparsers(dest="command")

    find_parser = subparsers.add_parser("find", help="find uenv in the CSCS registry")
    find_parser.add_argument("-s", "--system", required=False, type=str)
    find_parser.add_argument("-a", "--uarch", required=False, type=str)
    find_parser.add_argument("--build", action="store_true",
                             help="enable undeployed builds", required=False)
    find_parser.add_argument("uenv", nargs="?", default=None, type=str)

    pull_parser = subparsers.add_parser("pull", help="pull a uenv from the CSCS registry")
    pull_parser.add_argument("-s", "--system", required=False, type=str)
    pull_parser.add_argument("-a", "--uarch", required=False, type=str)
    pull_parser.add_argument("--build", action="store_true", required=False,
                             help="enable undeployed builds")
    pull_parser.add_argument("uenv", nargs="?", default=None, type=str)

    list_parser = subparsers.add_parser("list", help="list cached images")
    list_parser.add_argument("-s", "--system", required=False, type=str)
    list_parser.add_argument("-a", "--uarch", required=False, type=str)
    list_parser.add_argument("uenv", nargs="?", default=None, type=str)

    create_parser = subparsers.add_parser("create",
                    help="create a local file system repository")
    create_parser.add_argument("--exists-ok", action="store_true", required=False,
                    help="no error if the local registry exists")

    deploy_parser = subparsers.add_parser("deploy",
                    help="deploy a uenv to the 'deploy' namespace, visible to all users")
    deploy_parser.add_argument("-t", "--tag", required=False, default="latest", type=str)
    deploy_parser.add_argument("source", nargs="?", default=None, type=str)

    return parser

def get_options(args):
    options = {}
    if args.system is None:
        sys_name = os.getenv("CLUSTER_NAME")
        if sys_name is None:
            raise ValueError("No system name was provided, and the CLUSTER_NAME environment variable is not set.")
        options["system"] = sys_name
    else:
        options["system"] = args.system

    options["name"] = args.uenv
    options["uarch"] = args.uarch

    return options

def get_filter(args):
    options = get_options(args)
    img_filter = {"system": options["system"]}

    for key, value in parse_uenv_string(options["name"]).items():
        if value is not None:
            img_filter[key] = value

    if options["uarch"] is not None:
        img_filter["uarch"] = options["uarch"]

    return img_filter


def relative_path_from_record(record):
    return f"{record.sha256}"


# pretty print a list of Record
def print_records(records):
    if len(records)>0:
        print(terminal.colorize(f"{'uenv/version:tag':40}{'uarch':6}{'date':10} {'sha256':16} {'size':<10}", "yellow"))
        for r in records:
            namestr = f"{r.name}/{r.version}"
            tagstr = f"{r.tag}"
            label = namestr + ":" + tagstr
            datestr = r.date.strftime("%Y-%m-%d")
            S = r.size
            if S<1024:
                size_str = f"{S:<} bytes"
            elif S<1024*1024:
                size_str = f"{(S/1024):<.0f} kB"
            elif S<1024*1024*1024:
                size_str = f"{(S/(1024*1024)):<.0f} MB"
            else:
                size_str = f"{(S/(1024*1024*1024)):<.1f} GB"
            print(f"{label:<40}{r.uarch:6}{datestr:10} {r.sha256[:16]:16} {size_str:<10}")

# return dictionary {"name", "version", "tag"} from a uenv description string
#       "prgenv_gnu"              -> ("prgenv_gnu", None, None)
#       "prgenv_gnu/23.11"        -> ("prgenv_gnu", "23.11", None)
#       "prgenv_gnu/23.11:latest" -> ("prgenv_gnu", "23.11", "latest")
def parse_uenv_string(desc: str) -> dict:
    name = version = tag = None

    if desc:
        splits = desc.split("/",1)
        name = splits[0]
        if len(splits)>1:
            splits = splits[1].split(":",1)
            version = splits[0]
            tag = splits[1] if len(splits)>1 else None

    return {"name": name, "version": version, "tag": tag}

# the path used to store a users cached images and meta data
def uenv_repo_path(path: str=None) -> str:
    if path is not None:
        return path

    # check whether the image path has been explicitly set:
    path = os.environ.get('UENV_REPO_PATH')
    if path is not None:
        return path

    # if not, try to use the path $SCRATCH/.uenv-images/, if SCRATCH exists
    path = os.environ.get('SCRATCH')
    if path is not None:
        return path + "/.uenv-images"

    terminal.error("No repository path available: set UENV_REPO_PATH or use the --repo flag")

# return the relative path of an image
def record_path(record):
    return f"{record.system}/{record.uarch}/{record.name}/{record.version}/{record.tag}"

# the path of the image corresponding to a specific image in the user cache
def uenv_record_path(record):
    store = uenv_image_path()
    if store:
        return store + "/images/" + relative_path_from_record(record)
    return store

def is_valid_sha256(s: str):
    pattern = re.compile(r'^[a-fA-F-0-9]{64}$')
    return True if pattern.match(s) else False

def is_short_sha256(s: str):
    pattern = re.compile(r'^[a-fA-F-0-9]{16}$')
    return True if pattern.match(s) else False

if __name__ == "__main__":

    parser = make_argparser()
    args = parser.parse_args()
    terminal.use_colored_output(args.no_color)
    if args.command is None:
        parser.print_help()
        sys.exit(0)

    terminal.info(f"command mode: {args.command}")

    if args.command in ["find", "pull"]:
        img_filter = get_filter(args)
        terminal.info(f"filter for remote repo {img_filter}")
        terminal.info(f"using {'build' if args.build else 'deploy'} remote repo")

        try:
            deploy, build = jfrog.query()
        except RuntimeError as err:
            terminal.error(f"{str(err)}")

        terminal.info(f"downloaded jfrog meta data: build->{len(build.images)}, deploy->{len(deploy.images)}")

        remote_database = build if args.build else deploy

        records = remote_database.find_records(**img_filter)

        terminal.info(f"The following records matched the query: {records}")

        if args.command == "find":
            if len(records)>0:
                print_records(records)
            else:
                print("no images match the query")

        elif args.command == "pull":
            # verify that there is at least one image that matches the query
            if len(records)==0:
                terminal.error(f"no images match the query {args.uenv}")

            # check that there is only one uenv name
            if len(set([r.name for r in records]))>1:
                print_records(records)
                print()
                terminal.error(f"ambiguous uenv {args.uenv}")

            # check that there is only one uenv name
            if len(set([r.uarch for r in records]))>1:
                print_records(records)
                print()
                terminal.error(
                        "more than one uarch matches the the requested uenv. "
                        "Specify the desired uarch with the --uarch flag")

            t = records[0]
            source_address = jfrog.address(t, 'build' if args.build else 'deploy')

            terminal.info(f"pulling {t} from {source_address} {t.size/(1024*1024):.0f} MB")

            repo_path = uenv_repo_path(args.repo)
            terminal.info(f"repo path: {repo_path}")

            with flock.Lock(f"{repo_path}/index.json", flock.Lock.WRITE) as lk:
                cache = datastore.FileSystemCache(repo_path)

                image_path = cache.image_path(t)

                # if the record isn't already in the filesystem repo download it
                if not cache.get_record(t.sha256):
                    terminal.info(f"downloading {t.sha256}")
                    # download the image using oras
                    oras.run_command(["pull", "-o", image_path, source_address])
                    # add the record to the cache
                    terminal.info(f"updating file system cache")
                    cache.add_record(t)
                    # publish the updated index
                    terminal.info(f"publishing file system cache")
                    cache.publish()
                else:
                    terminal.info(f"image {t.sha256} is already in the cache")
                terminal.info(f"image downloaded at {image_path}/store.squashfs")

        sys.exit(0)

    elif args.command == "list":
        repo_path = uenv_repo_path(args.repo)
        terminal.info(f"repo path: {repo_path}")

        img_filter = get_filter(args)

        with flock.Lock(f"{repo_path}/index.json", flock.Lock.READ) as lk:
            fscache = datastore.FileSystemCache(repo_path)

            records = fscache.database.find_records(**img_filter)
            print_records(records)

        sys.exit(0)

    elif args.command == "create":
        repo_path = uenv_repo_path(args.repo)
        terminal.info(f"repo path: {repo_path}")

        try:
            datastore.FileSystemCache.create(repo_path, exists_ok=args.exists_ok)
        except Exception as err:
            terminal.error(f"unable to find or initialise the local registry: {str(err)}")

        sys.exit(0)

    elif args.command == "deploy":
        tags = [ tag.strip() for tag in args.tag.split(',') ]
        source = args.source
        terminal.info(f"deploying {source} with {tags}")

        try:
            _, build_database = jfrog.query()
        except RuntimeError as err:
            terminal.error(f"{str(err)}")
        terminal.info(f"downloaded jfrog build meta data: {len(build_database.images)} images")

        # after this block, record is the record of the requested source
        if DataStore.is_valid_sha(source):
            # lookup using sha256
            source_record = build_database.get_record(source)
            terminal.info(f"image to deploy: {source_record}")
            if not source_record:
                terminal.error(f"no record in the build repository matches the hash {source}")
            source_record = source_record[0]
        else:
            img_filter = {}
            for key, value in parse_uenv_string(source).items():
                if value is not None:
                    img_filter[key] = value
                else:
                    terminal.error(f"source {source} must have full name/version:tag format")

            # expect that src has [name, version, tag] keys
            records = build_database.find_records(**img_filter)

            if not (len(records)==1):
                terminal.error(f"source {source} is not an image in the build repository")
            source_record = records[0][0]

        target_record = copy.deepcopy(source_record)
        target_record.tag = ','.join(tags)

        terminal.info(f"source: {source_record}")
        source_address = jfrog.address(source_record, 'build')
        target_address = jfrog.address(target_record, 'deploy')
        terminal.info(f"source address: {source_address}")
        terminal.info(f"target address: {target_address}")

        oras.run_command(["cp", "--concurrency", "10", "--recursive", source_address, target_address])

        sys.exit(0)


