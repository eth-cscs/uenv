#!/usr/bin/env python3

# for handling http requests with the middleware
import argparse
from datetime import datetime, timezone
import os
import requests
import subprocess
import sys

# Choose whether to use colored output.
# - by default colored output is ON
# - if the flag --no-color is passed it is OFF
# - if the environment variable NO_COLOR is set it is OFF
def use_colored_output(cli_arg):
    # The --no-color argument overrides all environment variables if passed.
    if cli_arg:
        return False

    # Check the env. var NO_COLOR and disable color if set.
    if os.environ.get('NO_COLOR') is not None:
        color_var = os.environ.get('NO_COLOR')
        if len(color_var)>0 and color_var != "0":
            return False

    return True

def colorize(string, color):
    colors = {
        "red":     "31",
        "green":   "32",
        "yellow":  "33",
        "blue":    "34",
        "magenta": "35",
        "cyan":    "36",
        "white":   "37",
    }
    if colored_output:
        return f"\033[1;{colors[color]}m{string}\033[0m"
    else:
        return string

def print_error_and_exit(message):
    print(f"{colorize('error', 'red')} {message}", file=sys.stderr)
    exit(1)

def exit_with_success():
    exit(0)

def make_argparser():
    parser = argparse.ArgumentParser(description=("Interact with the uenv artifactory"))
    parser.add_argument("--no-color", action="store_true",
            help="disable color output")
    parser.add_argument("--build", action="store_true",
            help="enable undeployed builds",
            required=False)

    subparsers = parser.add_subparsers(dest="command")

    find_parser = subparsers.add_parser("find", help="find uenv in the CSCS registry")
    find_parser.add_argument("-s", "--system", required=False, type=str)
    find_parser.add_argument("-a", "--uarch", required=False, type=str)
    find_parser.add_argument("uenv", nargs="?", default=None, type=str)

    pull_parser = subparsers.add_parser("pull", help="pull a uenv from the CSCS registry")
    pull_parser.add_argument("-s", "--system", required=False, type=str)
    pull_parser.add_argument("-a", "--uarch", required=False, type=str)
    pull_parser.add_argument("uenv", nargs="?", default=None, type=str)

    pull_parser = subparsers.add_parser("list", help="list cached images")
    pull_parser.add_argument("-s", "--system", required=False, type=str)
    pull_parser.add_argument("-a", "--uarch", required=False, type=str)
    pull_parser.add_argument("uenv", nargs="?", default=None, type=str)

    return parser

def get_options(args):
    options = {}
    if args.system is None:
        sys_name = os.getenv("CLUSTER_NAME")
        if sys_name is None:
            raise ValueError("No system name was provided, and the CLUSTER_NAME environment variable is not set.")
        options["system"] = sys_name
    else:
        options["system"] = args.system

    options["name"] = args.uenv
    options["uarch"] = args.uarch

    options["repo"] = "deploy" if not args.build else "build"
    return options


def get_filter(args):
    options = get_options(args)
    img_filter = {"system": options["system"]}

    for key, value in parse_uenv_string(options["name"]).items():
        if value is not None:
            img_filter[key] = value

    if options["uarch"] is not None:
        img_filter["uarch"] = options["uarch"]
    repo = options["repo"]

    return repo, img_filter

class Record:
    # build/eiger/zen2/cp2k/2023/1133706947
    def __init__(self, system, uarch, name, version, tag, date, sha256):
        self._system  = system
        self._uarch   = uarch
        self._name    = name
        self._version = version
        self._tag     = tag
        self._date    = date
        self._sha256  = sha256

    #def to_set(self):
        ## don't use date in the set, because date is not used for comparison.
        #return (self._system, self._uarch, self._name, self._version, self._tag)

    def __eq__(self, other):
        if not isinstance(other, Record):
            return False
        return self.sha256==other.sha256

    def __lt__(self, other):
        if self.system  < other.system: return True
        if other.system < self.system: return False
        if self.uarch   < other.uarch: return True
        if other.uarch  < self.uarch: return False
        if self.name    < other.name: return True
        if other.name   < self.name: return False
        if self.version < other.version: return True
        if other.version< self.version: return False
        if self.tag     < other.tag: return True
        #if other.tag    < self.tag: return False
        return False

    #def __hash__(self):
        #return hash(self.to_set())

    def __str__(self):
        return f"{self.name}/{self.version}:{self.tag} @ {self.system}:{self.uarch}"

    def __repr__(self):
        return f"Record({self.system}, {self.uarch}, {self.name}, {self.version}, {self.tag})"

    @property
    def system(self):
        return self._system

    @property
    def uarch(self):
        return self._uarch

    @property
    def name(self):
        return self._name

    @property
    def date(self):
        return self._date

    @property
    def version(self):
        return self._version

    @property
    def tag(self):
        return self._tag

    @property
    def sha256(self):
        return self._sha256

# pretty print a list of Record
def print_records(records):
    if len(records)>0:
        print(colorize(f"{'uenv/version:tag':40}{'uarch':6}{'date':10} {'sha256':64}", "yellow"))
        for r in records:
            namestr = f"{r.name}/{r.version}"
            tagstr = f"{r.tag}"
            label = namestr + ":" + tagstr
            datestr = r.date.strftime("%Y-%m-%d")
            print(f"{label:<40}{r.uarch:6}{datestr:10} {r.sha256:64}")

class DataStore:
    def __init__(self):
        self.store = {"system": {}, "uarch": {}, "name": {}, "version": {}, "tag": {}}
        self.images = {}

    def add_record(self, record, date, sha256):
        fields = record.split("/")
        if len(fields) != 5:
            raise ValueError("Record must have exactly 5 fields")

        system, uarch, name, version, tag = fields
        r = Record(system, uarch, name, version, tag, date, sha256)

        self.images[sha256] = r
        self.store["system"] .setdefault(system, []).append(sha256)
        self.store["uarch"]  .setdefault(uarch, []).append(sha256)
        self.store["name"]   .setdefault(name, []).append(sha256)
        self.store["version"].setdefault(version, []).append(sha256)
        self.store["tag"]    .setdefault(tag, []).append(sha256)

    def get_records(self, **constraints):
        if not constraints:
            raise ValueError("At least one constraint must be provided")

        for field in constraints:
            if field not in self.store:
                raise ValueError(f"Invalid field: {field}. Must be one of 'system', 'uarch', 'name', 'version', 'tag'")

        # Find matching records for each constraint
        matching_records_sets = [
            set(self.store[field].get(value, [])) for field, value in constraints.items()
        ]

        # Intersect all sets of matching records
        if matching_records_sets:
            unique = set.intersection(*matching_records_sets)
        else:
            unique = set()

        #results = list(unique)
        results = [self.images[sha] for sha in unique]
        results.sort(reverse=True)
        return results

# The https://cicd-ext-mw.cscs.ch/uenv/list API endpoint returns
# a list of images in the jfrog uenv.
#
#{
#  "results":
#  [
#    {
#      "repo" : "uenv",
#      "path" : "build/clariden/zen3/prgenv-gnu/23.11/1094139948",
#      "name" : "manifest.json",
#      "created" : "2023-12-04T09:05:44.034Z",
#      "sha256" : "134c04d01bb3583726804a094b144d3637997877ef6162d1fe19eabff3c72c3a",
#      "stats" : [{
#        "downloaded" : "2023-12-11T17:56:59.052Z",
#        "downloads" : 11
#      }]
#    },
#    ...
#  ],
#  "range" :
#  {
#    "start_pos" : 0,
#    "end_pos" : 22,
#    "total" : 22
#  }
#}
#
# The query_jfrog function returns the "results" array in this response

def query_jfrog():
    try:
        # GET request to the middleware
        url = "https://cicd-ext-mw.cscs.ch/uenv/list"
        response = requests.get(url)
        response.raise_for_status()

        data = response.json()

        return data["results"]

    except error:
        raise RuntimeError("unable to access the JFrog uenv API.")

def to_datetime(string):
    # In Python 3.6, datetime.fromisoformat is not available.
    # Manually parsing the string.
    dt_format = '%Y-%m-%dT%H:%M:%S.%fZ'
    return datetime.strptime(string, dt_format).replace(tzinfo=timezone.utc)

# return dictionary {"name", "version", "tag"} from a uenv description string
#       "prgenv_gnu"              -> ("prgenv_gnu", None, None)
#       "prgenv_gnu/23.11"        -> ("prgenv_gnu", "23.11", None)
#       "prgenv_gnu/23.11:latest" -> ("prgenv_gnu", "23.11", "latest")
def parse_uenv_string(desc):
    name = version = tag = None

    if desc:
        splits = desc.split("/",1)
        name = splits[0]
        if len(splits)>1:
            splits = splits[1].split(":",1)
            version = splits[0]
            tag = splits[1] if len(splits)>1 else None

    return {"name": name, "version": version, "tag": tag}

def run_oras_command(args):
    try:
        command = ['oras'] + args
        print(f"{colorize('running oras', 'yellow')}: {' '.join(command)}")
       #result = subprocess.run(
       #    command,
       #    stdout=subprocess.PIPE,  # Capture standard output
       #    stderr=subprocess.PIPE,  # Capture standard error
       #    check=True,  # Raise exception if command fails
       #    encoding='utf-8'  # Decode output from bytes to string
       #)

       ## Print standard output
       #print("Output:\n", result.stdout)

    except subprocess.CalledProcessError as e:
        # Print error message along with captured standard error
        print("An error occurred:\n", e.stderr)

# the path used to store a users cached images and meta data
def uenv_repo_path():
    # check whether the image path has been explicitly set:
    path = os.environ.get('UENV_IMAGE_PATH')
    if path is not None:
        try:
            if not os.path.exists(path):
                os.makedirs(path)
            return path
        except Exception as error:
            # Handle any exception that occurs during the process
            raise RuntimeError(f"the UENV_IMAGE_PATH={path} could not be accessed or created")

    # if not, try to use the path $SCRATCH/.uenv-images/, if SCRATCH exists
    path = os.environ.get('SCRATCH')
    if path is not None:
        try:
            path = path + "/.uenv-images"
            if not os.path.exists(path):
                os.makedirs(path)
            return path
        except Exception as error:
            # Handle any exception that occurs during the process
            raise RuntimeError(f"the image path SCRATCH/.uenv-images={path} could not be accessed or created")

    return None

# the path with cached images
def uenv_image_path():
    store = uenv_repo_path()
    if store:
        return store + "/images"
    return None

# return the relative path of an image
def record_path(record):
    return f"{record.system}/{record.uarch}/{record.name}/{record.version}/{record.tag}"

# the path of the image corresponding to a specific image in the user cache
def uenv_record_path(record):
    store = uenv_image_path()
    if store:
        return store + "/" + record_path(record)
    return store

if __name__ == "__main__":
    parser = make_argparser()
    args = parser.parse_args()

    global colored_output
    colored_output = use_colored_output(args.no_color)

    # hoist option filtering and parsing the databse
    # outside the find and pull commands
    options = get_options(args)

    if args.command in ["find", "pull"]:
        raw_records = query_jfrog()
        database = {"build": DataStore(), "deploy": DataStore()}
        for record in raw_records:
            path = record["path"]

            date = to_datetime(record["created"])
            sha256 = record["sha256"]
            if path.startswith("build/"):
                database["build"].add_record(path[len("build/"):], date, sha256)
            if path.startswith("deploy/"):
                database["deploy"].add_record(path[len("deploy/"):], date, sha256)

        repo, img_filter = get_filter(args)
        records = database[repo].get_records(**img_filter)
        if args.command == "find":
            print_records(records)

            # verify that there is at least one image that matches the query
            if len(records)==0:
                print("no images match the query")

            exit_with_success()

        if args.command == "pull":
            # verify that there is at least one image that matches the query
            if len(records)==0:
                print_error_and_exit(f"no images match the query {args.uenv}")

            # check that there is only one uenv name
            if len(set([r.name for r in records]))>1:
                print_records(records)
                print()
                print_error_and_exit(f"ambiguous uenv {args.uenv}")

            # check that there is only one uenv name
            if len(set([r.uarch for r in records]))>1:
                print_records(records)
                print()
                print_error_and_exit(f"more than one uarch matches the the requested uenv. Specificy the desired uarch with the --uarch flag")

            base = f"jfrog.svc.cscs.ch/uenv/{repo}"
            t = records[0]
            target = f"{t.system}/{t.uarch}/{t.name}/{t.version}"

            # Call the function
            path = uenv_record_path(t)
            if path is not None:
                print(f"PATH: {colorize(path, 'magenta')}")
                run_oras_command(["pull", "-o", path, f"{base}/{target}:{t.tag}"])

            else:
                print_error_and_exit("set UENV_IMAGE_PATH to specify where uenv images should be stored")

            exit_with_success()

    if args.command == "list":
        repo_path = uenv_image_path()
        print(f"repo  {colorize(repo_path, 'yellow')}")
        index_file = repo_path + "/index.json"
        print(f"index {colorize(index_file, 'yellow')}")

